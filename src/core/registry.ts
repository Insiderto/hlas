/**
 * @module core/registry
 * @description Provides a global registry for managing UI components and their metadata,
 * enabling interaction via the `window.hlas` API. It also handles features like
 * highlighting components and orchestrating guided tours using `driver.js`.
 */

import { ActionSchema, ComponentEntry, ScreenComponent } from "./types";
import { driver } from "driver.js";
import "driver.js/dist/driver.css";

/**
/**
 * @interface TourStep
 * @description Defines the structure for a single step in a guided tour.
 * This interface is used by the {@link Registry.startTour} method and is also
 * exported for use by consumers who want to define tours.
 * @property {string} id - The ID of the component to highlight in this step. This ID must correspond
 *                         to a component registered in the {@link Registry}.
 * @property {string} [title] - An optional title for the tour step popover. If not provided,
 *                              the component's registered name might be used.
 * @property {string} [description] - An optional description or content for the tour step popover.
 *                                   If not provided, the component's registered description might be used.
 * @property {"top" | "right" | "bottom" | "left"} [position="bottom"] - The preferred position of the popover
 *                                                                    relative to the element. Defaults to "bottom".
 * @property {"start" | "center" | "end"} [align="center"] - The alignment of the popover. Defaults to "center".
 * @see window.hlas.startTour
 * @see Registry.startTour
 */
interface TourStep {
  id: string;
  title?: string;
  description?: string;
  position?: "top" | "right" | "bottom" | "left";
  align?: "start" | "center" | "end";
}

/**
 * @class Registry
 * @description Manages a collection of UI components, their metadata (name, description, actions),
 * and their corresponding DOM elements. It provides methods for registering, unregistering,
 * finding, and interacting with these components. This class underpins the `window.hlas` API.
 *
 * This class is instantiated as a singleton and exported as the default module export.
 *
 * @property {Map<string, ComponentEntry>} components - A private map storing registered components,
 *                                                    keyed by their unique ID.
 * @property {ReturnType<typeof driver> | undefined} tourDriverInstance - Private instance of `driver.js`
 *                                                                       used for guided tours.
 * @property {ReturnType<typeof driver> | undefined} highlightDriverInstance - Private instance of `driver.js`
 *                                                                            used for highlighting individual components.
 * @property {boolean} activeTour - Private flag indicating if a tour is currently active.
 */
class Registry {
  private components: Map<string, ComponentEntry> = new Map();
  private tourDriverInstance: ReturnType<typeof driver> | undefined;
  private highlightDriverInstance: ReturnType<typeof driver> | undefined;
  private activeTour: boolean = false;

  /**
   * @constructor
   * @description Initializes the Registry. In a browser environment, it sets up a `driver.js` instance
   * for highlighting after a short delay to ensure the DOM is loaded.
   */
  constructor() {
    // Initialize driver instance when DOM is available
    if (typeof window !== "undefined") {
      // Delay initialization to ensure DOM is fully loaded
      setTimeout(() => {
        this.highlightDriverInstance = driver({
          animate: true,
          smoothScroll: true,
          allowClose: true,
          showProgress: true, // Show progress for single highlights for consistency with tours.
          stagePadding: 10,
          // @ts-expect-error - opacity is supported by driver.js but not in their types
          opacity: 0.5,
          // onDestroyStarted and onDestroyed are removed as highlight() manages its own lifecycle
          // by explicitly calling destroy() before highlighting. allowClose: true handles user closing.
        });
      }, 0);
    }
  }

  /**
   * Registers a component with the HLAS system, making it discoverable and interactive.
   * Sets `data-hlas-*` attributes on the provided HTML element for identification and metadata.
   *
   * @param {string} id - The unique identifier for the component. Often generated by `useId()`.
   * @param {HTMLElement} element - The HTML DOM element associated with the component.
   * @param {string} name - A human-readable name for the component (e.g., "Submit Button", "Username Input").
   * @param {ActionSchema[]} [actions=[]] - An array of actions the component supports. Defaults to an empty array.
   *                                        Each action's `id` and `name` are used.
   * @param {string} [description] - An optional description of the component's purpose or behavior.
   * @returns {string} The `id` of the registered component.
   *
   * @remarks
   * - This method is typically called by the {@link useHlasActions} hook or {@link Describe} components.
   * - The `data-hlas-name` and `data-hlas-description` attributes set here are the primary source
   *   of truth for the component's metadata in the registry. If a component is also wrapped with
   *   the {@link action} HOC, the values provided here will generally override any similar attributes
   *   set by the HOC for the registry's perspective.
   */
  register(
    id: string,
    element: HTMLElement,
    name: string,
    actions: ActionSchema[] = [],
    description?: string,
  ): string {
    const componentId = id;

    this.components.set(componentId, {
      id: componentId,
      element,
      actions,
      name,
      description,
    });

    // Add data attributes to the DOM element
    element.setAttribute("data-hlas-id", componentId);
    element.setAttribute("data-hlas-name", name);

    if (description) {
      element.setAttribute("data-hlas-description", description);
    }

    // Add action data
    if (actions.length > 0) {
      element.setAttribute(
        "data-hlas-actions",
        actions.map((a) => a.id).join(","),
      );
    }

    return componentId;
  }

  /**
   * Unregisters a component from the HLAS system using its ID.
   * This should be called when the component is unmounted to prevent memory leaks
   * and stale references.
   *
   * @param {string} id - The ID of the component to unregister.
   * @returns {boolean} `true` if the component was found and removed, `false` otherwise.
   * @remarks Typically called automatically during the cleanup phase of `useEffect` in
   *          hooks or components that use {@link Registry.register}.
   */
  unregister(id: string): boolean {
    return this.components.delete(id);
  }

  /**
   * Finds registered components whose name or description includes the given query string.
   * The search is case-insensitive.
   *
   * @param {string} query - The string to search for within component names and descriptions.
   * @returns {ComponentEntry[]} An array of {@link ComponentEntry} objects for components
   *                             that match the query. Returns an empty array if no matches are found.
   */
  find(query: string): ComponentEntry[] {
    const results: ComponentEntry[] = [];
    const lowerQuery = query.toLowerCase();

    for (const component of this.components.values()) {
      if (
        component.name.toLowerCase().includes(lowerQuery) ||
        (component.description &&
          component.description.toLowerCase().includes(lowerQuery))
      ) {
        results.push(component);
      }
    }

    return results;
  }

  /**
   * Dispatches a custom event (`hlas:execute`) on the component's DOM element
   * to trigger a specific action.
   *
   * The actual execution logic for the action is expected to be handled by an event listener
   * set up on the component, typically by the {@link useHlasActions} hook. This method
   * itself does not execute the action's behavior.
   *
   * @param {string} id - The ID of the component on which to execute the action.
   * @param {string} actionId - The identifier of the action to be executed (e.g., "click", "setValue").
   * @param {Record<string, unknown>} [params] - Optional parameters to pass to the action handler
   *                                             via the event's `detail` property.
   * @returns {boolean} `true` if the event was dispatched (i.e., the component was found),
   *                    `false` otherwise (e.g., component not found).
   */
  execute(
    id: string,
    actionId: string,
    params?: Record<string, unknown>,
  ): boolean {
    // This method dispatches a custom event that the useHlasActions hook listens for.
    // The hook is then responsible for invoking the actual action function.
    const component = this.components.get(id);

    if (!component) {
      console.error(`Component with ID ${id} not found`);
      return false;
    }

    const event = new CustomEvent("hlas:execute", {
      detail: {
        id,
        actionId,
        params: params || {},
      },
    });

    component.element.dispatchEvent(event);
    return true;
  }

  /**
   * Sets programmatic focus on the DOM element of a registered component.
   *
   * @param {string} id - The ID of the component to focus.
   * @returns {boolean} `true` if the component was found and its element is an `HTMLElement`
   *                    (focus was attempted), `false` otherwise.
   * @remarks The element must be focusable in the DOM for this to have a visual effect.
   */
  focus(id: string): boolean {
    const component = this.components.get(id);

    if (!component) {
      console.error(`Component with ID ${id} not found`);
      return false;
    }

    if (component.element instanceof HTMLElement) {
      component.element.focus();
      return true;
    }

    return false;
  }

  /**
   * @param {string} id - The ID of the component to highlight.
   * @param {number} [duration=2000] - The duration in milliseconds for the highlight to remain active.
   *                                   If 0 or negative, the highlight may persist until manually cleared
   *                                   or another highlight/tour starts.
   * @param {string} [title] - An optional title to display in the highlight popover.
   * @param {string} [description] - Optional descriptive text to display in the highlight popover.
   * @returns {boolean} `true` if the component was found and highlight was initiated, `false` otherwise.
   * @remarks This method uses `driver.js` to visually highlight the component.
   *          It will destroy any existing single-element highlight before creating a new one.
   */
  // The JSDoc for the HlasInterface in index.ts had a 'tooltip' param, which was incorrect.
  // This implementation correctly uses 'title' and 'description'.
  highlight(
    id: string,
    duration: number = 2000,
    title?: string,
    description?: string,
  ): boolean {
    // We don't need to destroy an active tour as we now have separate instances
    // for tour and highlight functionality

    const component = this.components.get(id);

    if (!component) {
      console.error(`Component with ID ${id} not found`);
      return false;
    }

    if (!this.highlightDriverInstance && typeof window !== "undefined") {
      // Initialize highlight driver if it wasn't due to initial window check or other reasons
      this.highlightDriverInstance = driver({
        animate: true,
        smoothScroll: true,
        allowClose: true,
        showProgress: false, // Typically false for single highlights
        stagePadding: 10,
      });
    }

    if (
      component.element instanceof HTMLElement &&
      this.highlightDriverInstance
    ) {
      // Ensure highlight driver is stopped before starting a new highlight
      this.highlightDriverInstance.destroy();

      //  Configure driver for this element
      this.highlightDriverInstance.highlight({
        element: component.element,
        popover: {
          // CAUTION: If title/description can come from untrusted (e.g., LLM) input,
          // ensure sanitization by the caller to prevent XSS,
          // as driver.js popover content behavior with HTML should be verified.
          title: title,
          description: description,
        },
      });

      // Automatically close highlight after duration
      if (duration > 0) {
        setTimeout(() => {
          this.highlightDriverInstance?.destroy();
        }, duration);
      }

      return true;
    }

    return false;
  }

  /**
   * Initiates a multi-step guided tour using `driver.js`.
   * Each step highlights a registered component and can display a title and description.
   *
   * @param {TourStep[]} steps - An array of {@link TourStep} objects defining the sequence and content of the tour.
   * @param {boolean} [autoStart=true] - If `true` (default), the tour starts immediately after configuration.
   *                                     If `false`, the tour is configured but not started (can be started manually if needed, though not exposed via `window.hlas` currently).
   * @returns {boolean} `true` if the tour was successfully configured (and possibly started),
   *                    `false` if no valid steps were provided or an error occurred.
   * @remarks If a tour is already active, it will be destroyed before starting a new one.
   */
  startTour(steps: TourStep[], autoStart: boolean = true): boolean {
    try {
      // If there's already an active tour, destroy it first
      if (this.tourDriverInstance) {
        this.tourDriverInstance.destroy();
        this.activeTour = false;
      }

      // Validate and collect elements for the tour
      const driverSteps = [];

      for (const step of steps) {
        const component = this.components.get(step.id);
        if (!component || !(component.element instanceof HTMLElement)) {
          console.warn(
            `Component with ID ${step.id} not found or not an HTML element`,
          );
          continue;
        }

        driverSteps.push({
          element: component.element,
          popover: {
            // CAUTION: If title/description can come from untrusted (e.g., LLM) input,
            // ensure sanitization by the caller to prevent XSS,
            // as driver.js popover content behavior with HTML should be verified.
            title: step.title || component.name,
            description: step.description || component.description || "",
            side: step.position || "bottom",
            align: step.align || "center",
          },
        });
      }

      if (driverSteps.length === 0) {
        console.error("No valid steps found for tour");
        return false;
      }

      // Create a new Tour Driver instance with the steps
      this.tourDriverInstance = driver({
        animate: true,
        smoothScroll: true,
        allowClose: true,
        showProgress: true,
        steps: driverSteps,
        // @ts-expect-error - opacity is supported by driver.js but not in their types
        opacity: 0.5,
        onDestroyStarted: () => {
          this.tourDriverInstance?.destroy();
          this.activeTour = false;
        },
        onDestroyed: () => {
          this.activeTour = false;
        },
      });

      // Start the tour if requested
      if (autoStart) {
        this.tourDriverInstance.drive();
        this.activeTour = true;
      }

      return true;
    } catch (error) {
      console.error("Error starting tour:", error);
      return false;
    }
  }

  /**
   * Highlight a component by ID using Driver.js
   * @param id Component ID to highlight
   * @param duration Duration in milliseconds (defaults to 2000ms)
   * @param title Optional title to show (can be provided by LLM)
   * @param description Optional description to show (can be provided by LLM)
   */
  /**
   * Retrieves a representation of all currently registered components.
   * This method is used to provide a snapshot of the UI's interactable elements and their state
   * to an external system like an LLM.
   *
   * @returns {ScreenComponent[]} An array of {@link ScreenComponent} objects, each describing a
   *                              registered component. The visibility of components is not determined
   *                              by this method by default (see {@link ScreenComponent.visible}).
   */
  readScreen(): ScreenComponent[] {
    const results: ScreenComponent[] = [];

    for (const component of this.components.values()) {
      // Visibility is not determined by readScreen by default.
      // If a future feature adds visibility checks, the 'visible' field in ScreenComponent can be populated.

      // Extract content from data attributes if available
      let content: unknown = undefined;
      const contentAttr = component.element.getAttribute("data-hlas-content");

      if (contentAttr) {
        try {
          content = JSON.parse(contentAttr);
        } catch {
          content = contentAttr;
        }
      }

      results.push({
        id: component.id,
        name: component.name,
        description: component.description,
        // visible property is intentionally not set here.
        actions: component.actions,
        content,
      });
    }

    return results;
  }
}

// Create global registry instance
const registry = new Registry();

export default registry;
